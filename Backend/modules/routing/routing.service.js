import axios from "axios";
import * as routingRepository from "./routing.repository.js";
import * as errors from "../../errors/errors.js";
import Route from "./routing.model.js";

const EXTERNEL_URL = "http://localhost:8000";
const CVRP_SERVICE_URL = process.env.CVRP_SERVICE_URL;

export async function generateRoutesAuto() {
  const depot = await routingRepository.getDepotLocation();

  const productions = await routingRepository.getPendingProduction();

  // Handling Error
  if (productions.length === 0) {
    throw new errors.NotFoundError(
      "No pending productions available at this moment",
    );
  }

  const availableTrucks = await routingRepository.getAllAvailableTrucks();

  if (availableTrucks.length === 0) {
    throw new errors.NotFoundError("No trucks available at this moment");
  }

  const vehicle_capacities = [];

  availableTrucks.forEach((truck) => {
    vehicle_capacities.push(truck.capacity);
  });

  // Building VRP input
  const coords = [[depot.lon, depot.lat]];
  const demands = [0];
  const productionIndexMap = [null];

  productions.forEach((prod) => {
    coords.push([prod.farmer.location.lon, prod.farmer.location.lat]);
    demands.push(prod.volume);
    productionIndexMap.push(prod);
  });

  // Check for VRP validity (If any route not satisfy this requirement will throw error) -------------
  const totalDemand = demands.reduce(
    (accumulated, currentValue) => accumulated + currentValue,
    0,
  );
  const totalCapacity = vehicle_capacities.reduce(
    (accumulated, currentValue) => accumulated + currentValue,
    0,
  );

  if (totalCapacity < totalDemand) {
    throw new errors.BadRequestError(`Insufficient capacity in route`);
  }

  // --------------------------------------------------------------------------------------------------

  // Handling Error
  if (coords.length !== demands.length) {
    throw new errors.InternalError("coords and demands length must be same");
  }

  const req = {
    coords,
    demands,
    vehicle_capacities,
  };

  console.log(JSON.stringify(req));

  let vrpResponse;
  let routes;

  try {
    vrpResponse = await axios.post(
      // "http://localhost:8000/route-optimize/auto",
      `${CVRP_SERVICE_URL}/api/routeOptimize/auto`,
      {
        coords,
        demands,
        vehicle_capacities,
      },
    );
  } catch (err) {
    throw new Error(`VRP service unreachable: ${err.message}`);
  }

  // Handling Error
  if (!vrpResponse.data || !Array.isArray(vrpResponse.data.routes)) {
    throw new Error("Invalid VRP response: routes missing");
  }

  routes = vrpResponse.data.routes;

  console.log(JSON.stringify(routes));

  // Handling Error
  if (routes.length === 0) {
    return {
      success: true,
      message: "No routes generated by VRP at this time",
      routes: [],
    };
  }

  // Creating routes (Mapping)
  for (const route of routes) {
    const vehicleIndex = route.vehicle_id;

    // Handling Error
    if (!availableTrucks[vehicleIndex]) {
      throw new Error(`Invalid vehicle index returned: ${vehicleIndex}`);
    }

    route.vehicle_id = availableTrucks[vehicleIndex]._id;
    route.license_no = availableTrucks[vehicleIndex].license_no;
    route.model = availableTrucks[vehicleIndex].model;
    route.route = availableTrucks[vehicleIndex].route;

    let order = 1;
    const mappedStops = route.stops.map((stop) => {
      if (
        typeof stop.node !== "number" ||
        stop.node >= productionIndexMap.length
      ) {
        throw new Error(`Invalid stop node index: ${stop.node}`);
      }
      const p = productionIndexMap[stop.node] || null;

      return {
        order: order++,
        node: stop.node,
        production: p
          ? {
              _id: p._id,
              volume: p.volume,
              farmer: p.farmer,
              status: p.status,
            }
          : null,
        load_after_visit: stop.load_after_visit,
      };
    });

    route.stops = mappedStops;
  }

  return routes;
}

// Generate VRP solution route-wise-all -----------------------------------------------------------------
export async function generateRouteWiseAll() {
  const productions = await routingRepository.getPendingProduction();
  const depot = await routingRepository.getDepotLocation();

  // Handling Error
  if (!productions || productions.length === 0) {
    throw new errors.NotFoundError(
      "No pending productions available at this moment",
    );
  }

  const availableTrucks = await routingRepository.getAllAvailableTrucks();

  if (availableTrucks.length === 0) {
    throw new errors.NotFoundError("No trucks available at this moment");
  }

  const vehicle_capacities = [];

  availableTrucks.forEach((truck) => {
    vehicle_capacities.push(truck.capacity);
  });

  const requestBody = [];
  const depotCoords = [depot.lon, depot.lat];

  const productionIndexMap = [];

  for (let i = 1; i <= 6; i++) {
    const mapping = { route: i, productionIndexList: [null], vehicles: [] };
    const structure = {
      route: i,
      coords: [],
      demands: [],
      vehicle_capacities: [],
      vehicles: [],
    };

    structure.coords.push(depotCoords);
    structure.demands.push(0);

    // Production related operations------
    productions.forEach((prod) => {
      if (Number(prod.farmer.route) === i) {
        structure.coords.push([
          prod.farmer.location.lon,
          prod.farmer.location.lat,
        ]);
        structure.demands.push(Number(prod.volume));
        mapping.productionIndexList.push(prod);
      }
    });

    if (structure.coords.length === 1) {
      // No farmers in this route, only depot
      productionIndexMap.push(mapping);
      continue; // do NOT push to requestBody
    }

    // Vehicle related operations------
    const vehiclesForRoute = availableTrucks.filter((v) => v.route === i);
    if (vehiclesForRoute.length === 0) {
      throw new errors.InternalError(`No vehicle assigned for route ${i}`);
    }

    // push all vehicles
    mapping.vehicles.push(...vehiclesForRoute);
    structure.vehicles.push(...vehiclesForRoute);

    const capacities = vehiclesForRoute.map((v) => v.capacity);

    structure.vehicle_capacities.push(...capacities);

    productionIndexMap.push(mapping);
    requestBody.push(structure);

    // Check for VRP validity (If any route not satisfy this requirement will throw error)
    const totalDemand = structure.demands.reduce(
      (accumulated, currentValue) => accumulated + currentValue,
      0,
    );
    const totalCapacity = structure.vehicle_capacities.reduce(
      (accumulated, currentValue) => accumulated + currentValue,
      0,
    );

    if (totalCapacity < totalDemand) {
      throw new errors.BadRequestError(`Insufficient capacity in route ${i}`);
    }
  }

  console.log(JSON.stringify(requestBody));

  console.log(JSON.stringify({ productionIndexMap }));

  // Calling to VRP Service to get the solution------
  let vrpResponse;

  try {
    vrpResponse = await axios.post(
      // "http://localhost:8000/route-optimize/route-wise/all",
      `${CVRP_SERVICE_URL}/api/routeOptimize/routeWise`,
      requestBody,
    );
  } catch (err) {
    console.log(err);
    throw new errors.InternalError(`VRP service unreachable: ${err.message}`);
  }

  const routes = vrpResponse.data;

  console.log(JSON.stringify(routes));

  // Handling Error
  if (routes.length === 0)
    throw new errors.InternalError("No routes generated by VRP at this time");

  const routeList = [];

  routes.forEach((route) => {
    const route_id = route["route"];

    const mapping = productionIndexMap.find((obj) => obj.route === route_id);

    // Handling Error
    if (!mapping) {
      throw new Error(`No production mapping found for route ${route_id}`);
    }

    route.routes.forEach((r) => {
      const mappedStops = r.stops.map((stop) => {
        const p = mapping.productionIndexList[stop.node] || null;
        let order = 1;
        return {
          order: order++,
          node: stop.node,
          production: p
            ? {
                _id: p._id,
                volume: p.volume,
                farmer: p.farmer,
              }
            : null,
          load_after_visit: stop.load_after_visit,
        };
      });

      r.stops = mappedStops;
      r.license_no = mapping.vehicles[r.vehicle_id].license_no;
      r.truck_model = mapping.vehicles[r.vehicle_id].model;
      r.truck_route = mapping.vehicles[r.vehicle_id].route;
      routeList.push(r);
    });
  });

  return routeList;
}

// Generate VRP solution route-wise by route --------------------------------------------------------
export async function generateRouteWise(routeId) {
  const productions =
    await routingRepository.getPendingProductionByRoute(routeId);

  const depot = await routingRepository.getDepotLocation();

  if (!depot) throw new errors.NotFoundError("Depot Location not found");

  // Handling Error
  if (productions.length === 0) {
    throw new errors.NotFoundError(
      `No pending productions available for Route - ${routeId} at this moment`,
    );
  }

  const availableTrucks =
    await routingRepository.getAllAvailableTrucksByRoute(routeId);

  if (availableTrucks.length === 0) {
    throw new errors.NotFoundError(`No trucks available for route ${routeId}`);
  }

  const vehicleCapacities = [];
  const vehicleList = [];
  availableTrucks.forEach((truck) => {
    vehicleCapacities.push(truck.capacity);
    vehicleList.push(truck);
  });

  // Building VRP input
  const coords = [[depot.lon, depot.lat]];
  const demands = [0];
  const productionIndexMap = [null];

  productions.forEach((prod) => {
    coords.push([prod.farmer.location.lon, prod.farmer.location.lat]);
    demands.push(prod.volume);
    productionIndexMap.push(prod);
  });

  // Check for VRP validity (If any route not satisfy this requirement will throw error) -------------
  const totalDemand = demands.reduce(
    (accumulated, currentValue) => accumulated + currentValue,
    0,
  );
  const totalCapacity = vehicleCapacities.reduce(
    (accumulated, currentValue) => accumulated + currentValue,
    0,
  );

  if (totalCapacity < totalDemand) {
    throw new errors.BadRequestError(
      `Insufficient capacity in route ${routeId}`,
    );
  }

  // --------------------------------------------------------------------------------------------------

  // Handling Error
  if (coords.length !== demands.length) {
    throw new errors.InternalError("coords and demands length must be same");
  }

  let vrpResponse;
  let routes;

  try {
    vrpResponse = await axios.post(
      // "http://localhost:8000/route-optimize/auto",
      `${CVRP_SERVICE_URL}/api/routeOptimize/auto`,
      {
        coords,
        demands,
        vehicle_capacities: vehicleCapacities,
      },
    );
  } catch (err) {
    throw new Error(`VRP service unreachable: ${err.message}`);
  }

  // Handling Error
  if (!vrpResponse.data || !Array.isArray(vrpResponse.data.routes)) {
    throw new Error("Invalid VRP response: routes missing");
  }

  routes = vrpResponse.data.routes;
  // Handling Error
  if (routes.length === 0) {
    return {
      success: true,
      message: "No routes generated by VRP at this time",
      routes: [],
    };
  }

  console.log("Output: ", routes);

  // Creating routes (Mapping)
  for (const route of routes) {
    const vehicleIndex = route.vehicle_id;

    // Handling Error
    if (!vehicleList[vehicleIndex]) {
      throw new Error(`Invalid vehicle index returned: ${vehicleIndex}`);
    }

    route.vehicle_id = vehicleList[vehicleIndex].vehicle_id;
    route.license_no = vehicleList[vehicleIndex].license_no;
    route.model = vehicleList[vehicleIndex].model;
    route.route = vehicleList[vehicleIndex].route;

    let order = 1;
    const mappedStops = route.stops.map((stop) => {
      if (
        typeof stop.node !== "number" ||
        stop.node >= productionIndexMap.length
      ) {
        throw new Error(`Invalid stop node index: ${stop.node}`);
      }
      const p = productionIndexMap[stop.node] || null;

      return {
        order: order++,
        node: stop.node,
        production: p
          ? {
              _id: p._id,
              volume: p.volume,
              farmer: p.farmer,
              status: p.status,
            }
          : null,
        load_after_visit: stop.load_after_visit,
      };
    });

    route.stops = mappedStops;
  }

  return routes;
}

// Dispatch & save vehicle routes (Done)--------------------------------------------------------
export async function dispatchRoutes(routes) {
  if (!routes || routes.length === 0)
    throw new errors.BadRequestError("No routes to save");

  const productionIds = [];

  routes.forEach((route) => {
    route.status = "dispatched";
    route.stops.forEach((stop) => {
      if (stop.production !== null) {
        productionIds.push(stop.production?._id);
        stop.production.status = "awaiting pickup";
      }
    });
  });

  // Update Productions
  if (productionIds.length > 0) {
    await routingRepository.bulkUpdateProductionsToAwaiting(productionIds);
  }

  // Save routes
  await routingRepository.saveRoutes(routes);
}

// Get all Pending Routes --------------------------------------------------------
export async function getPendingRoutesService(driver_id) {
  const pendingRoutes = await routingRepository.getPendingRoutesRepo(driver_id);
  return pendingRoutes;
}

// Get a Pending Route by ID --------------------------------------------------------
export async function getRouteById(route_id) {
  const route = await routingRepository.getRouteById(route_id);

  if (!route) {
    throw new errors.NotFoundError("Route not found");
  }

  return route;
}

export async function confirmProductionPickup(
  route_id,
  production_id,
  driver_id,
  collectedVolume,
) {
  if (collectedVolume < 0)
    throw new errors.BadRequestError(
      "Collected volume cannot be smaller than 0",
    );

  const route = await routingRepository.getRouteById(route_id);

  if (!route) throw new errors.NotFoundError("Route not found");

  if (route.driver_id.toString() !== driver_id)
    throw new errors.UnauthorizedError("This route belongs to other driver");

  const stop = route.stops.find(
    (s) => s.production && s.production._id.equals(production_id),
  );

  if (!stop) {
    throw new errors.NotFoundError("Production stop not found");
  }

  if (stop.production.status === "collected") {
    return {
      alreadyProcessed: true,
    };
  }

  stop.production.status = "collected";
  stop.production.collectedVolume = collectedVolume;

  await routingRepository.saveRoute(route);

  // update production - synchronously
  await routingRepository.updateProductionState(production_id, "collected");

  return {
    alreadyProcessed: false,
  };
}

export async function issuePickupReportService(
  route_id,
  production_id,
  driver_id,
  failureReason,
) {
  const route = await routingRepository.getRouteById(route_id);

  if (!route) throw new errors.NotFoundError("Route not found");

  if (route.driver_id.toString() !== driver_id)
    throw new errors.UnauthorizedError("This route belongs to other driver");

  const stop = route.stops.find(
    (s) => s.production && s.production._id.equals(production_id),
  );

  if (!stop) {
    throw new errors.NotFoundError("Production stop not found");
  }

  if (stop.production.status === "failed") {
    return {
      alreadyProcessed: true,
    };
  }

  stop.production.status = "failed";
  stop.production.collectedVolume = 0;

  stop.production.failure_reason = failureReason;

  await routingRepository.saveRoute(route);

  // update production - synchronously
  await routingRepository.updateProductionState(production_id, "failed");

  return {
    alreadyProcessed: false,
  };
}

// Canceling activated route --------------------------------------------------------
export async function cancelRouteActivation(route_id) {
  const route = await routingRepository.getRouteById(route_id);

  if (!route) {
    throw new errors.NotFoundError("Route not found");
  }

  route.status = "dispatched";
  route.active = false;
  route.driver_id = null;

  const productionIds = [];

  for (const stop of route.stops) {
    const prod = stop.production;

    if (prod && prod.status !== "pending") {
      prod.status = "awaiting pickup";
      productionIds.push(prod._id);
    }
  }

  if (productionIds.length > 0) {
    await routingRepository.bulkUpdateProductionsToAwaiting(productionIds);
  }

  await routingRepository.saveRoute(route);

  return;
}

import { calculateRouteETA } from "../../util/calculateRouteETA.js";

// Route activation --------------------------------------------------------
export async function activateRoute(driver_id, route_id) {
  const route = await routingRepository.getRouteById(route_id);

  if (!route) {
    throw new errors.NotFoundError("Route not found");
  }

  if (route.active && route.driver_id.toString() !== driver_id) {
    throw new errors.BadRequestError("Route is activated by another driver");
  }

  if (route.active && route.driver_id.toString() === driver_id) {
    return; // idempotent success
  }

  // Check if this driver has any other active route
  const otherActiveRoute = await Route.findOne({
    driver_id: driver_id,
    active: true,
    _id: { $ne: route_id }, // exclude current route
  });

  if (otherActiveRoute) {
    throw new errors.BadRequestError(
      "Cannot activate this route. Driver already has another active route.",
    );
  }

  route.active = true;
  route.driver_id = driver_id;
  route.activatedAt = new Date();
  route.status = "inProgress";

  await routingRepository.saveRoute(route);

  calculateRouteETA(route);

  return;
}

// Route Completion --------------------------------------------------------
export async function routeCompletetionService(route_id, driver_id) {
  const route = await routingRepository.getRouteById(route_id);

  if (!route) {
    throw new errors.NotFoundError("Route not found");
  }

  console.log(route.driver_id.toString());
  console.log(driver_id);

  if (route.active && route.driver_id.toString() !== driver_id) {
    throw new errors.BadRequestError("Route is activated by another driver");
  }

  if (route.status !== "inProgress") {
    throw new errors.BadRequestError(
      "Only in-progress routes can be completed",
    );
  }

  if (route.status === "completed") return;

  route.status = "completed";
  route.active = false;

  await routingRepository.saveRoute(route);

  return;
}

export async function getCompletedRoutesService(driver_id) {
  const result = await routingRepository.getCompletedRoutesByDriver(driver_id);

  if (!result || result.length === 0) return [];

  return result;
}

export async function getDispatchedService() {
  const result = await routingRepository.getDispatchedRoutes();

  return result;
}

export async function getInProgreeService() {
  const result = await routingRepository.getInProgressRoutes();

  return result;
}

// Delete Routes (Sync production done) -----------------------------------------
export async function deleteRouteService(route_id) {
  if (!route_id) throw errors.BadRequestError("Route ID is empty");

  const result = await routingRepository.deleteRouteRepository(route_id);

  if (!result) throw errors.NotFoundError("Route not found");

  // We should reset the Productions also
  const productionIds = result.stops
    .filter((stop) => stop.production?._id)
    .map((stop) => stop.production._id);
  await routingRepository.bulkUpdateProductionToPending(productionIds);

  // Reset productions only if needed
  if (productionIds.length > 0) {
    await routingRepository.bulkUpdateProductionToPending(productionIds);
  }

  return;
}

export async function getHistoryService() {
  const result = await routingRepository.getCompletedAndCanceledRoutes();

  return result;
}
